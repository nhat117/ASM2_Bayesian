type=saveType)
}
# Open new graph
openGraph(width=nCol*7.0/3,height=nRow*2.0)
layout( matrix( 1:(nRow*nCol) , nrow=nRow, byrow=TRUE ) )
par( mar=c(4,4,2.5,0.5) , mgp=c(2.5,0.7,0) )
}
# Increment and return panel count:
panelCount = panelCount+1
return(panelCount)
}
}}
# Call the plotMCMC_HD function with the coda samples
plotMCMC_HD(codaSamples = codaSamples, data = myData, xName=c("Area","Bedrooms","Bathrooms","CarParks","PropertyType"), yName="SalePrice")
# Call the plotMCMC_HD function with the coda samples
plotMCMC_HD(codaSamples = codaSamples, data = myData, xName=c("Area","Bedrooms","Bathrooms","CarParks","PropertyType"), yName="SalePrice")
# Clear R's environment and close all graphics
graphics.off() # This closes all of R's graphics windows.
rm(list=ls())  # Careful! This clears all of R's memory!
# Load required libraries
library(ggplot2)
library(ggpubr)
library(ks)
library(rjags)
library(runjags)
# Set the working directory#setwd("~/Documents/MATH2269_Bayesian/2024/presentations/Module 6/Application2")
source("DBDA2E-utilities.R")
#===============PRELIMINARY FUNCTIONS FOR POSTERIOR INFERENCES====================
smryMCMC_HD = function(  codaSamples , compVal = NULL,  saveName=NULL) {
summaryInfo = NULL
mcmcMat = as.matrix(codaSamples,chains=TRUE)
paramName = colnames(mcmcMat)
for ( pName in paramName ) {
if (pName %in% colnames(compVal)){
if (!is.na(compVal[pName])) {
summaryInfo = rbind( summaryInfo , summarizePost( paramSampleVec = mcmcMat[,pName] ,
compVal = as.numeric(compVal[pName]) ))
}
else {
summaryInfo = rbind( summaryInfo , summarizePost( paramSampleVec = mcmcMat[,pName] ) )
}
} else {
summaryInfo = rbind( summaryInfo , summarizePost( paramSampleVec = mcmcMat[,pName] ) )
}
}
rownames(summaryInfo) = paramName
if ( !is.null(saveName) ) {
write.csv( summaryInfo , file=paste(saveName,"SummaryInfo.csv",sep="") )
}
return( summaryInfo )
}
#===============================================================================
# Include new prediction data
# Define the new prediction data (from the image you provided):
xPred <- array(NA, dim = c(5, 5))  # 5 properties with 5 predictors
# Populate the data (Area, Bedrooms, Bathrooms, CarParks, PropertyType)
xPred[1,] <- c(600, 2, 2, 1, 1)  # Property 1 (Unit)
xPred[2,] <- c(800, 3, 1, 2, 0)  # Property 2 (House)
xPred[3,] <- c(1500, 2, 1, 1, 0)  # Property 3 (House)
xPred[4,] <- c(2500, 5, 4, 4, 0)  # Property 4 (House)
xPred[5,] <- c(250, 3, 2, 1, 1)   # Property 5 (Unit)
# Load the data
myData <- read.csv("Assignment2PropertyPrices.csv")
# Perform random sampling of 50 rows
set.seed(42) # Set seed for reproducibility
myData <- myData[sample(nrow(myData), 100), ]
# Set the dependent and independent variables
y = myData$SalePrice  # Sale price in AUD
x = as.matrix(myData[,c("Area", "Bedrooms", "Bathrooms", "CarParks", "PropertyType")])
# Specify the data in a list, for later shipment to JAGS:
dataList <- list(
y = y,
x = x,
xPred = xPred,  # Include the new properties for prediction
Ntotal = length(y),
Nx = ncol(x),
Npred = 5  # Number of predictions (new properties)
)
# Specify initial values for MCMC
initsList <- list(
zbeta0 = 2000,
zbeta = c(100, 1, 1, 0.5, -1),
zVar = 1
)
#================JAGS MODEL================
modelString = "
# Standardize the data:
data {
# Define Mean and Variance of y
ym <- mean(y)
ysd <- sd(y)
# Standardize y
for (i in 1:Ntotal) {
zy[i] <- (y[i] - ym) / ysd
}
for (j in 1:Nx) {
xm[j] <- mean(x[,j])
xsd[j] <- sd(x[,j])
for (i in 1:Ntotal) {
zx[i,j] <- (x[i,j] - xm[j]) / xsd[j]
}
}
# Prior locations to reflect expert information
mu[1] <- 90       # Area (AUD/m2)
mu[2] <- 100000   # Bedrooms (AUD/bedroom)
mu[3] <- 0        # Bathrooms (No expert knowledge)
mu[4] <- 120000   # CarParks (AUD/car space)
mu[5] <- -150000  # PropertyType (AUD less for a unit compared to a house)
# Prior variances to reflect expert knowledge
Var[1] <- 10      # Strong prior for Area
Var[2] <- 10^5    # Weak prior for Bedrooms
Var[3] <- 10^7    # No expert knowledge for Bathrooms
Var[4] <- 999     # Strong prior for CarParks
Var[5] <- 10      # Very strong prior for PropertyType
# Compute corresponding prior means and variances for the standardized parameters
muZ[1:Nx] <- mu[1:Nx] * xsd[1:Nx] / ysd
}
# Specify the model for standardized data:
model {
for (i in 1:Ntotal) {
zy[i] ~ dnorm(zbeta0 + sum(zbeta[1:Nx] * zx[i,1:Nx]), 1/zsigma^2)
}
# Priors for standardized coefficients
zbeta0 ~ dnorm(0, 1/10^6)
for (j in 1:Nx) {
zbeta[j] ~ dnorm(muZ[j], 1/Var[j])
}
zsigma ~ dunif(1.0E-5, 1.0E+5)
# Transform to original scale:
beta[1:Nx] <- (zbeta[1:Nx] / xsd[1:Nx]) * ysd
beta0 <- zbeta0 * ysd + ym - sum(zbeta[1:Nx] * xm[1:Nx] / xsd[1:Nx]) * ysd
sigma <- zsigma * ysd
# Compute predictions at every step of the MCMC
pred1 <- beta0 + beta[1]*600 + beta[2]*2 + beta[3]*2 + beta[4]*1 + beta[5]*1
pred2 <- beta0 + beta[1]*800 + beta[2]*3 + beta[3]*1 + beta[4]*2 + beta[5]*0
}
" # close quote for modelString
# Write the model to a file
writeLines(modelString, con="TEMPmodel.txt")
# Parameters to monitor
parameters = c("beta0","beta","var","tau","zbeta0", "zbeta", "zVar", "pred")
# MCMC settings
adaptSteps = 500
burnInSteps = 1000
nChains = 2
thinSteps = 3
numSavedSteps = 10000
nIter = ceiling((numSavedSteps * thinSteps) / nChains)
# Run JAGS model
runJagsOut <- run.jags(
method="parallel",
model="TEMPmodel.txt",
monitor=parameters,
data=dataList,
inits=initsList,
n.chains=nChains,
adapt=adaptSteps,
burnin=burnInSteps,
sample=numSavedSteps,
thin=thinSteps,
summarise=FALSE,
plots=FALSE
)
# Convert the output to coda samples for further analysis
codaSamples = as.mcmc.list(runJagsOut)
#================PREDICTIONS===================
# Extract and summarize predictions for the new properties
summary(codaSamples)
predictions <- as.matrix(codaSamples)[,grep("pred", colnames(as.matrix(codaSamples)))]
# Present the posterior means for the predicted sale prices
apply(predictions, 2, mean)  # These are the predicted sale prices
#=============== Plot MCMC HD =================
plotMCMC_HD = function( codaSamples , data , xName="x" , yName="y" ,
showCurve=FALSE ,  pairsPlot=FALSE , compVal = NULL,
saveName=NULL , saveType="jpg" ) {
y = data[,yName]
x = as.matrix(data[,xName])
mcmcMat = as.matrix(codaSamples, chains=TRUE)
chainLength = NROW(mcmcMat)
zbeta0 = mcmcMat[,"zbeta0"]
zbeta  = mcmcMat[,grep("^zbeta$|^zbeta\\[", colnames(mcmcMat))]
if (ncol(x)==1) { zbeta = matrix(zbeta, ncol=1) }
zVar = mcmcMat[,"zVar"]
beta0 = mcmcMat[,"beta0"]
beta  = mcmcMat[,grep("^beta$|^beta\\[", colnames(mcmcMat))]
if (ncol(x)==1) { beta = matrix(beta, ncol=1) }
tau = mcmcMat[,"tau"]
pred1 = mcmcMat[,"pred[1]"]
pred2 = mcmcMat[,"pred[2]"]
#-----------------------------------------------------------------------------
# Marginal histograms:
decideOpenGraph = function( panelCount , saveName , finished=FALSE ,
nRow=2 , nCol=3 ) {
# If finishing a set:
if ( finished==TRUE ) {
if ( !is.null(saveName) ) {
saveGraph( file=paste0(saveName,ceiling((panelCount-1)/(nRow*nCol))),
type=saveType)
}
panelCount = 1 # re-set panelCount
return(panelCount)
} else {
# If this is first panel of a graph:
if ( ( panelCount %% (nRow*nCol) ) == 1 ) {
# If previous graph was open, save previous one:
if ( panelCount>1 & !is.null(saveName) ) {
saveGraph( file=paste0(saveName,(panelCount%/%(nRow*nCol))),
type=saveType)
}
# Open new graph
openGraph(width=nCol*7.0/3,height=nRow*2.0)
layout( matrix( 1:(nRow*nCol) , nrow=nRow, byrow=TRUE ) )
par( mar=c(4,4,2.5,0.5) , mgp=c(2.5,0.7,0) )
}
# Increment and return panel count:
panelCount = panelCount+1
return(panelCount)
}
}
# Plot marginal histograms:
panelCount = 1
panelCount = decideOpenGraph(panelCount, saveName=paste0(saveName,"PostMarg"))
histInfo = plotPost(beta0, cex.lab = 1.75, showCurve=showCurve, xlab=bquote(beta[0]), main="Intercept")
for (bIdx in 1:ncol(beta)) {
panelCount = decideOpenGraph(panelCount, saveName=paste0(saveName,"PostMarg"))
histInfo = plotPost(beta[,bIdx], cex.lab = 1.75, showCurve=showCurve, xlab=bquote(beta[.(bIdx)]), main=xName[bIdx])
}
panelCount = decideOpenGraph(panelCount, saveName=paste0(saveName,"PostMarg"))
histInfo = plotPost(tau, cex.lab = 1.75, showCurve=showCurve, xlab=bquote(tau), main="Scale")
# Plot predictions:
for (i in 1:2) {
panelCount = decideOpenGraph(panelCount, saveName=paste0(saveName,"PostMarg"))
histInfo = plotPost(mcmcMat[,paste0("pred[", i, "]")], cex.lab = 1.75, showCurve=showCurve, xlab=paste("pred", i), main=paste("Prediction", i))
}
decideOpenGraph = function( panelCount , saveName , finished=FALSE ,
nRow=2 , nCol=3 ) {
# If finishing a set:
if ( finished==TRUE ) {
if ( !is.null(saveName) ) {
saveGraph( file=paste0(saveName,ceiling((panelCount-1)/(nRow*nCol))),
type=saveType)
}
panelCount = 1 # re-set panelCount
return(panelCount)
} else {
# If this is first panel of a graph:
if ( ( panelCount %% (nRow*nCol) ) == 1 ) {
# If previous graph was open, save previous one:
if ( panelCount>1 & !is.null(saveName) ) {
saveGraph( file=paste0(saveName,(panelCount%/%(nRow*nCol))),
type=saveType)
}
# Open new graph
openGraph(width=nCol*7.0/3,height=nRow*2.0)
layout( matrix( 1:(nRow*nCol) , nrow=nRow, byrow=TRUE ) )
par( mar=c(4,4,2.5,0.5) , mgp=c(2.5,0.7,0) )
}
# Increment and return panel count:
panelCount = panelCount+1
return(panelCount)
}
}}
# Call the plotMCMC_HD function with the coda samples
plotMCMC_HD(codaSamples = codaSamples, data = myData, xName=c("Area","Bedrooms","Bathrooms","CarParks","PropertyType"), yName="SalePrice")
# Clear R's environment and close all graphics
graphics.off() # This closes all of R's graphics windows.
rm(list=ls())  # Careful! This clears all of R's memory!
# Load required libraries
library(ggplot2)
library(ggpubr)
library(ks)
library(rjags)
library(runjags)
# Set the working directory#setwd("~/Documents/MATH2269_Bayesian/2024/presentations/Module 6/Application2")
source("DBDA2E-utilities.R")
#===============PRELIMINARY FUNCTIONS FOR POSTERIOR INFERENCES====================
smryMCMC_HD = function(  codaSamples , compVal = NULL,  saveName=NULL) {
summaryInfo = NULL
mcmcMat = as.matrix(codaSamples,chains=TRUE)
paramName = colnames(mcmcMat)
for ( pName in paramName ) {
if (pName %in% colnames(compVal)){
if (!is.na(compVal[pName])) {
summaryInfo = rbind( summaryInfo , summarizePost( paramSampleVec = mcmcMat[,pName] ,
compVal = as.numeric(compVal[pName]) ))
}
else {
summaryInfo = rbind( summaryInfo , summarizePost( paramSampleVec = mcmcMat[,pName] ) )
}
} else {
summaryInfo = rbind( summaryInfo , summarizePost( paramSampleVec = mcmcMat[,pName] ) )
}
}
rownames(summaryInfo) = paramName
if ( !is.null(saveName) ) {
write.csv( summaryInfo , file=paste(saveName,"SummaryInfo.csv",sep="") )
}
return( summaryInfo )
}
#===============================================================================
# Include new prediction data
# Define the new prediction data (from the image you provided):
xPred <- array(NA, dim = c(5, 5))  # 5 properties with 5 predictors
# Populate the data (Area, Bedrooms, Bathrooms, CarParks, PropertyType)
xPred[1,] <- c(600, 2, 2, 1, 1)  # Property 1 (Unit)
xPred[2,] <- c(800, 3, 1, 2, 0)  # Property 2 (House)
xPred[3,] <- c(1500, 2, 1, 1, 0)  # Property 3 (House)
xPred[4,] <- c(2500, 5, 4, 4, 0)  # Property 4 (House)
xPred[5,] <- c(250, 3, 2, 1, 1)   # Property 5 (Unit)
# Load the data
myData <- read.csv("Assignment2PropertyPrices.csv")
# Perform random sampling of 50 rows
set.seed(42) # Set seed for reproducibility
myData <- myData[sample(nrow(myData), 100), ]
# Set the dependent and independent variables
y = myData$SalePrice  # Sale price in AUD
x = as.matrix(myData[,c("Area", "Bedrooms", "Bathrooms", "CarParks", "PropertyType")])
# Specify the data in a list, for later shipment to JAGS:
dataList <- list(
y = y,
x = x,
xPred = xPred,  # Include the new properties for prediction
Ntotal = length(y),
Nx = ncol(x),
Npred = 5  # Number of predictions (new properties)
)
# Specify initial values for MCMC
initsList <- list(
zbeta0 = 2000,
zbeta = c(100, 1, 1, 0.5, -1),
zVar = 1
)
#================JAGS MODEL================
modelString = "
# Standardize the data:
data {
# Define Mean and Variance of y
ym <- mean(y)
ysd <- sd(y)
# Standardize y
for (i in 1:Ntotal) {
zy[i] <- (y[i] - ym) / ysd
}
for (j in 1:Nx) {
xm[j] <- mean(x[,j])
xsd[j] <- sd(x[,j])
for (i in 1:Ntotal) {
zx[i,j] <- (x[i,j] - xm[j]) / xsd[j]
}
}
# Prior locations to reflect expert information
mu[1] <- 90       # Area (AUD/m2)
mu[2] <- 100000   # Bedrooms (AUD/bedroom)
mu[3] <- 0        # Bathrooms (No expert knowledge)
mu[4] <- 120000   # CarParks (AUD/car space)
mu[5] <- -150000  # PropertyType (AUD less for a unit compared to a house)
# Prior variances to reflect expert knowledge
Var[1] <- 10      # Strong prior for Area
Var[2] <- 10^5    # Weak prior for Bedrooms
Var[3] <- 10^7    # No expert knowledge for Bathrooms
Var[4] <- 999     # Strong prior for CarParks
Var[5] <- 10      # Very strong prior for PropertyType
# Compute corresponding prior means and variances for the standardized parameters
muZ[1:Nx] <- mu[1:Nx] * xsd[1:Nx] / ysd
}
# Specify the model for standardized data:
model {
for (i in 1:Ntotal) {
zy[i] ~ dnorm(zbeta0 + sum(zbeta[1:Nx] * zx[i,1:Nx]), 1/zsigma^2)
}
# Priors for standardized coefficients
zbeta0 ~ dnorm(0, 1/10^6)
for (j in 1:Nx) {
zbeta[j] ~ dnorm(muZ[j], 1/Var[j])
}
zsigma ~ dunif(1.0E-5, 1.0E+5)
# Transform to original scale:
beta[1:Nx] <- (zbeta[1:Nx] / xsd[1:Nx]) * ysd
beta0 <- zbeta0 * ysd + ym - sum(zbeta[1:Nx] * xm[1:Nx] / xsd[1:Nx]) * ysd
sigma <- zsigma * ysd
# Compute predictions at every step of the MCMC
pred1 <- beta0 + beta[1]*600 + beta[2]*2 + beta[3]*2 + beta[4]*1 + beta[5]*1
pred2 <- beta0 + beta[1]*800 + beta[2]*3 + beta[3]*1 + beta[4]*2 + beta[5]*0
}
" # close quote for modelString
# Write the model to a file
writeLines(modelString, con="TEMPmodel.txt")
# Parameters to monitor
parameters = c("beta0","beta","var","tau","zbeta0", "zbeta", "zVar", "pred")
# MCMC settings
adaptSteps = 500
burnInSteps = 1000
nChains = 2
thinSteps = 3
numSavedSteps = 10000
nIter = ceiling((numSavedSteps * thinSteps) / nChains)
# Run JAGS model
runJagsOut <- run.jags(
method="parallel",
model="TEMPmodel.txt",
monitor=parameters,
data=dataList,
inits=initsList,
n.chains=nChains,
adapt=adaptSteps,
burnin=burnInSteps,
sample=numSavedSteps,
thin=thinSteps,
summarise=FALSE,
plots=FALSE
)
# Convert the output to coda samples for further analysis
codaSamples = as.mcmc.list(runJagsOut)
#================PREDICTIONS===================
# Extract and summarize predictions for the new properties
summary(codaSamples)
predictions <- as.matrix(codaSamples)[,grep("pred", colnames(as.matrix(codaSamples)))]
# Present the posterior means for the predicted sale prices
apply(predictions, 2, mean)  # These are the predicted sale prices
#=============== Plot MCMC HD =================
plotMCMC_HD = function( codaSamples , data , xName="x" , yName="y" ,
showCurve=FALSE ,  pairsPlot=FALSE , compVal = NULL,
saveName=NULL , saveType="jpg" ) {
y = data[,yName]
x = as.matrix(data[,xName])
mcmcMat = as.matrix(codaSamples, chains=TRUE)
chainLength = NROW(mcmcMat)
zbeta0 = mcmcMat[,"zbeta0"]
zbeta  = mcmcMat[,grep("^zbeta$|^zbeta\\[", colnames(mcmcMat))]
if (ncol(x)==1) { zbeta = matrix(zbeta, ncol=1) }
zVar = mcmcMat[,"zVar"]
beta0 = mcmcMat[,"beta0"]
beta  = mcmcMat[,grep("^beta$|^beta\\[", colnames(mcmcMat))]
if (ncol(x)==1) { beta = matrix(beta, ncol=1) }
tau = mcmcMat[,"tau"]
pred1 = mcmcMat[,"pred[1]"]
pred2 = mcmcMat[,"pred[2]"]
#-----------------------------------------------------------------------------
# Marginal histograms:
decideOpenGraph = function( panelCount , saveName , finished=FALSE ,
nRow=2 , nCol=3 ) {
# If finishing a set:
if ( finished==TRUE ) {
if ( !is.null(saveName) ) {
saveGraph( file=paste0(saveName,ceiling((panelCount-1)/(nRow*nCol))),
type=saveType)
}
panelCount = 1 # re-set panelCount
return(panelCount)
} else {
# If this is first panel of a graph:
if ( ( panelCount %% (nRow*nCol) ) == 1 ) {
# If previous graph was open, save previous one:
if ( panelCount>1 & !is.null(saveName) ) {
saveGraph( file=paste0(saveName,(panelCount%/%(nRow*nCol))),
type=saveType)
}
# Open new graph
openGraph(width=nCol*7.0/3,height=nRow*2.0)
layout( matrix( 1:(nRow*nCol) , nrow=nRow, byrow=TRUE ) )
par( mar=c(4,4,2.5,0.5) , mgp=c(2.5,0.7,0) )
}
# Increment and return panel count:
panelCount = panelCount+1
return(panelCount)
}
}
# Plot marginal histograms:
panelCount = 1
panelCount = decideOpenGraph(panelCount, saveName=paste0(saveName,"PostMarg"))
histInfo = plotPost(beta0, cex.lab = 1.75, showCurve=showCurve, xlab=bquote(beta[0]), main="Intercept")
for (bIdx in 1:ncol(beta)) {
panelCount = decideOpenGraph(panelCount, saveName=paste0(saveName,"PostMarg"))
histInfo = plotPost(beta[,bIdx], cex.lab = 1.75, showCurve=showCurve, xlab=bquote(beta[.(bIdx)]), main=xName[bIdx])
}
panelCount = decideOpenGraph(panelCount, saveName=paste0(saveName,"PostMarg"))
histInfo = plotPost(tau, cex.lab = 1.75, showCurve=showCurve, xlab=bquote(tau), main="Scale")
# Plot predictions:
for (i in 1:2) {
panelCount = decideOpenGraph(panelCount, saveName=paste0(saveName,"PostMarg"))
histInfo = plotPost(mcmcMat[,paste0("pred[", i, "]")], cex.lab = 1.75, showCurve=showCurve, xlab=paste("pred", i), main=paste("Prediction", i))
}
decideOpenGraph = function( panelCount , saveName , finished=FALSE ,
nRow=2 , nCol=3 ) {
# If finishing a set:
if ( finished==TRUE ) {
if ( !is.null(saveName) ) {
saveGraph( file=paste0(saveName,ceiling((panelCount-1)/(nRow*nCol))),
type=saveType)
}
panelCount = 1 # re-set panelCount
return(panelCount)
} else {
# If this is first panel of a graph:
if ( ( panelCount %% (nRow*nCol) ) == 1 ) {
# If previous graph was open, save previous one:
if ( panelCount>1 & !is.null(saveName) ) {
saveGraph( file=paste0(saveName,(panelCount%/%(nRow*nCol))),
type=saveType)
}
# Open new graph
openGraph(width=nCol*7.0/3,height=nRow*2.0)
layout( matrix( 1:(nRow*nCol) , nrow=nRow, byrow=TRUE ) )
par( mar=c(4,4,2.5,0.5) , mgp=c(2.5,0.7,0) )
}
# Increment and return panel count:
panelCount = panelCount+1
return(panelCount)
}
}}
# Call the plotMCMC_HD function with the coda samples
plotMCMC_HD(codaSamples = codaSamples, data = myData, xName=c("Area","Bedrooms","Bathrooms","CarParks","PropertyType"), yName="SalePrice")
